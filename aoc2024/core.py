# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_parser.ipynb.

# %% auto 0
__all__ = ['Parser', 'PRV', 'char', 'nchar', 'satisfy', 'digit', 'ascii_letter', 'many', 'sequence', 'mapper', 'accumulator',
           'digits', 'integer', 'ws', 'ws_', 'choice', 'nl', 'nl_', 'find', 'drop']

# %% ../nbs/00_parser.ipynb 1
class Parser:
    def __init__(self, input):
        self.input = input
        self.head = 0
        self.length = len(input)

    def peek(self):
        return self.input[self.head]

    def next(self):
        ret = self.peek()
        self.head += 1
        return ret

    def nextn(self,n):
        ret = self.input[self.head:self.head+n]
        if len(ret) == n:
            self.head+=n
            return ret
        raise Exception("not enough input")
            

    def r(self):
        self.head = 0

    def step(self): self.head += 1

    def __len__(self): return self.length
        
    def __repr__(self): return f"{self.input[:self.head]}|{self.input[self.head:]}"


# %% ../nbs/00_parser.ipynb 3
class PRV():
    def __init__(self,v='',s=True,e=''):
        self.s = s
        self.v = v
        self.e = e
        
    def __bool__(self): return self.s
    
    def __repr__(self): return f"({self.s},{self.v},{self.e})"
    
    def __eq__(self,other): return self.v==other.v and self.s==other.s and self.e==other.e

# %% ../nbs/00_parser.ipynb 4
def char():
    def p(input):
        try:
            n = input.next()
            return PRV(n)
        except:
            return PRV(s=False,e='end of input')

    return p

# %% ../nbs/00_parser.ipynb 5
def nchar(n):
    def p(input):
        try: return PRV(input.nextn(n))
        except: return PRV(s=False,e='end of input')
    return p
                    

# %% ../nbs/00_parser.ipynb 8
def satisfy(parser, acceptor):
    def p(input):
        head = input.head
        res = parser(input)
        if res:
            if acceptor(res.v): return res
            else: 
                input.head = head
                return PRV(s=False,e='satisfy failed')
        else:
            return res

    return p

# %% ../nbs/00_parser.ipynb 9
def digit():
    return satisfy(char(), lambda x: x in "0123456789")


def ascii_letter():
    return satisfy(
        char(), lambda x: x in "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
    )

# %% ../nbs/00_parser.ipynb 12
def many(parser):
    def p(input):
        acc = []
        head = input.head
        while res := parser(input):
            head = input.head
            acc.append(res.v)
        input.head=head
        return PRV(acc)

    return p

# %% ../nbs/00_parser.ipynb 14
def sequence(parsers):
    def p(input):
        head =input.head
        acc = []
        for parser in parsers:
            res = parser(input)
            if res: acc.append(res.v)
            else: 
                input.head=head
                return PRV(s=False,e=f"sequence failed")
            
        return PRV([x for x in acc if x])
    
    return p

# %% ../nbs/00_parser.ipynb 16
def mapper(parser, funcs):
    def p(input):
        res = parser(input)
        if res:
            for f in funcs:
                res.v = f(res.v)
        return res

    return p

# %% ../nbs/00_parser.ipynb 17
def accumulator(parser, acc):
    def p(input):
        while True:
            h = input.head
            r = parser(input)
            if r: acc.add(r.v)
            else:
                input.head = h
                break
        return PRV(acc)
    return p

# %% ../nbs/00_parser.ipynb 18
def digits():
    def helper(x):
        if len(x) == 1:
            return x[0]
        else:
            return ''.join([x[0]]+x[1])
    return mapper(sequence([digit(), many(digit())]), 
                  [helper])

# %% ../nbs/00_parser.ipynb 20
def integer():
    return mapper(digits(), [lambda x: int(x)])

# %% ../nbs/00_parser.ipynb 22
def ws():
    return many(satisfy(char(), lambda x: x[0] in " \t"))

def ws_():
    def p(input):
        res = ws()(input)
        res.v = []
        return res
    return p
    

# %% ../nbs/00_parser.ipynb 23
def choice(parsers):
    def p(input):
        for parser in parsers:
            h=input.head
            r = parser(input)
            if r:
                return r
        return PRV(s=False,e="choice failed")
    return p

# %% ../nbs/00_parser.ipynb 26
def nl():
    return satisfy(char(), lambda x: x == "\n")

def nl_():
    def p(input):
        res = nl()(input)
        res.v = []
        return res
    return p


# %% ../nbs/00_parser.ipynb 27
def find(parser):
    def p(input):
        while input.head <= len(input):
            r = parser(input)
            if r: return r
            input.step()
        return PRV(s=False,e="find failed")
    return p

# %% ../nbs/00_parser.ipynb 29
def drop(parser): 
    def p(input):
        r = parser(input)
        if r: return PRV('')
        else: return r
    return p
